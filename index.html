<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Troubleshooting Steps — Put Them in Order</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 16px;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      color: #222;
    }

    .game {
      max-width: 980px;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 16px;
    }

    h1 {
      margin-top: 0;
      font-size: 1.5rem;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .panel {
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      padding: 12px;
      background: #fafafa;
    }

    .panel h2 {
      margin: 0 0 8px;
      font-size: 1.1rem;
    }

    .panel-note {
      margin: 0 0 10px;
      color: #555;
      font-size: 0.95rem;
    }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .slot {
      border: 2px dashed #b6b6b6;
      background: #fff;
      border-radius: 8px;
      min-height: 48px;
      padding: 6px;
      display: flex;
      align-items: stretch;
      gap: 8px;
    }

    .slot.drop-hot,
    .choices.drop-hot {
      border-color: #7f8ea3;
    }

    .slot-number {
      width: 30px;
      min-width: 30px;
      border-radius: 999px;
      background: #ececec;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #333;
    }

    .slot-content {
      flex: 1;
      display: flex;
      align-items: center;
      min-height: 44px;
    }

    .mark {
      width: 24px;
      min-width: 24px;
      text-align: center;
      font-weight: bold;
      font-size: 1.1rem;
    }

    .slot.correct {
      border-style: solid;
      border-color: #2e9b45;
    }

    .slot.incorrect {
      border-style: solid;
      border-color: #c62828;
    }

    .choices {
      border: 2px dashed #b6b6b6;
      background: #fff;
      border-radius: 8px;
      min-height: 340px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card {
      border: 1px solid #9aa5b1;
      background: #f3f7fc;
      border-radius: 8px;
      padding: 10px;
      min-height: 48px;
      display: flex;
      align-items: center;
      cursor: grab;
      -webkit-user-select: none;
      user-select: none;
    }

    .card.dragging {
      cursor: grabbing;
      opacity: 0.6;
    }

    .card.selected {
      border: 2px solid #e8a100;
      background: #fff7dd;
    }

    .controls {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      min-height: 44px;
      border: 1px solid #8d8d8d;
      background: #ececec;
      border-radius: 6px;
      padding: 8px 14px;
      font-weight: bold;
      cursor: pointer;
    }

    #message {
      margin-top: 12px;
      min-height: 24px;
      font-weight: bold;
    }

    @media (max-width: 760px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="game">
    <h1>Troubleshooting Steps — Put Them in Order</h1>

    <section class="layout">
      <section class="panel">
        <h2>Slots</h2>
        <p class="panel-note">Beginning → End</p>
        <div id="slots" class="slots" aria-label="Step slots"></div>
      </section>

      <section class="panel">
        <h2>Choices</h2>
        <div id="choices" class="choices" aria-label="Choices area"></div>
      </section>
    </section>

    <div class="controls">
      <button id="checkBtn" type="button">Check Answers</button>
      <button id="resetBtn" type="button">Reset</button>
    </div>

    <div id="message" aria-live="polite"></div>
  </main>

  <script>
    (function () {
      const stepData = [
        { id: 'step1', text: 'Identify the problem.' },
        { id: 'step2', text: 'Establish a theory of the most likely cause (start with the obvious).' },
        { id: 'step3', text: 'Test the theory to determine the cause.' },
        { id: 'step4', text: 'Establish a plan to fix the problem and carry out the solution.' },
        { id: 'step5', text: 'Verify full system functionality and, if appropriate, implement preventive measures.' },
        { id: 'step6', text: 'Document findings, actions taken, and outcomes.' }
      ];

      const correctOrder = stepData.map(s => s.id);

      let choices = [];
      let slots = new Array(6).fill(null);
      let selectedCardId = null;
      let hasChecked = false;
      let isDragging = false;
      let dragCardId = null;

      const slotsEl = document.getElementById('slots');
      const choicesEl = document.getElementById('choices');
      const messageEl = document.getElementById('message');
      const checkBtn = document.getElementById('checkBtn');
      const resetBtn = document.getElementById('resetBtn');

      function getStepText(id) {
        const step = stepData.find(s => s.id === id);
        return step ? step.text : '';
      }

      function shuffle(array) {
        const arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
        return arr;
      }

      function clearChecksAfterMove() {
        if (hasChecked) {
          hasChecked = false;
          clearFeedback();
          messageEl.textContent = 'Answers changed. Press Check Answers to regrade.';
        }
      }

      function clearFeedback() {
        // Feedback state is represented by hasChecked and cleared in render.
      }

      function removeCardFromCurrentLocation(cardId) {
        const inChoice = choices.indexOf(cardId);
        if (inChoice !== -1) choices.splice(inChoice, 1);

        const slotIndex = slots.indexOf(cardId);
        if (slotIndex !== -1) slots[slotIndex] = null;
      }

      function moveCardToSlot(cardId, slotIndex) {
        if (slotIndex < 0 || slotIndex > 5) return;

        clearChecksAfterMove();

        const existing = slots[slotIndex];
        const fromSlotIndex = slots.indexOf(cardId);

        removeCardFromCurrentLocation(cardId);

        slots[slotIndex] = cardId;

        if (existing && existing !== cardId) {
          if (fromSlotIndex !== -1 && fromSlotIndex !== slotIndex) {
            slots[fromSlotIndex] = existing;
          } else {
            choices.push(existing);
          }
        }

        selectedCardId = null;
        render();
      }

      function moveCardToChoices(cardId) {
        clearChecksAfterMove();
        removeCardFromCurrentLocation(cardId);
        if (!choices.includes(cardId)) choices.push(cardId);
        selectedCardId = null;
        render();
      }

      function onCardClick(cardId) {
        if (isDragging) return;

        if (selectedCardId === null) {
          selectedCardId = cardId;
        } else if (selectedCardId === cardId) {
          selectedCardId = null;
        } else {
          selectedCardId = cardId;
        }
        render();
      }

      function onDragStartCard(e, cardId) {
        isDragging = true;
        dragCardId = cardId;
        selectedCardId = null;
        e.dataTransfer.setData('text/plain', cardId);
        e.dataTransfer.effectAllowed = 'move';
        e.currentTarget.classList.add('dragging');
      }

      function onDragEndCard(e) {
        e.currentTarget.classList.remove('dragging');
        dragCardId = null;
        document.querySelectorAll('.drop-hot').forEach(function (el) {
          el.classList.remove('drop-hot');
        });
        setTimeout(function () {
          isDragging = false;
        }, 0);
      }

      function makeCard(cardId) {
        const card = document.createElement('div');
        card.className = 'card';
        card.textContent = getStepText(cardId);
        card.dataset.cardId = cardId;
        card.draggable = true;
        card.setAttribute('draggable', 'true');

        if (selectedCardId === cardId) {
          card.classList.add('selected');
        }

        card.addEventListener('click', function (e) {
          e.stopPropagation();
          onCardClick(cardId);
        });

        card.addEventListener('dragstart', function (e) {
          onDragStartCard(e, cardId);
        });

        card.addEventListener('dragend', function (e) {
          onDragEndCard(e);
        });

        return card;
      }

      function renderSlots() {
        slotsEl.innerHTML = '';

        for (let i = 0; i < 6; i++) {
          const slot = document.createElement('div');
          slot.className = 'slot';
          slot.dataset.slotIndex = String(i);

          const number = document.createElement('div');
          number.className = 'slot-number';
          number.textContent = String(i + 1);

          const content = document.createElement('div');
          content.className = 'slot-content';

          if (slots[i]) {
            content.appendChild(makeCard(slots[i]));
          }

          const mark = document.createElement('div');
          mark.className = 'mark';

          if (hasChecked) {
            if (slots[i] === correctOrder[i]) {
              slot.classList.add('correct');
              mark.textContent = '✓';
            } else {
              slot.classList.add('incorrect');
              mark.textContent = '✗';
            }
          }

          slot.appendChild(number);
          slot.appendChild(content);
          slot.appendChild(mark);

          slot.addEventListener('click', function () {
            if (isDragging) return;
            if (selectedCardId) {
              moveCardToSlot(selectedCardId, i);
            }
          });

          slot.addEventListener('dragenter', function (e) {
            e.preventDefault();
            slot.classList.add('drop-hot');
          });

          slot.addEventListener('dragleave', function () {
            slot.classList.remove('drop-hot');
          });

          slot.addEventListener('dragover', function (e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          });

          slot.addEventListener('drop', function (e) {
            e.preventDefault();
            slot.classList.remove('drop-hot');
            const cardId = e.dataTransfer.getData('text/plain') || dragCardId;
            if (!cardId) return;
            moveCardToSlot(cardId, i);
          });

          slotsEl.appendChild(slot);
        }
      }

      function renderChoices() {
        choicesEl.innerHTML = '';
        choices.forEach(function (cardId) {
          choicesEl.appendChild(makeCard(cardId));
        });
      }

      function render() {
        renderSlots();
        renderChoices();
      }

      choicesEl.addEventListener('click', function () {
        if (isDragging) return;
        if (selectedCardId) {
          moveCardToChoices(selectedCardId);
        }
      });

      choicesEl.addEventListener('dragenter', function (e) {
        e.preventDefault();
        choicesEl.classList.add('drop-hot');
      });

      choicesEl.addEventListener('dragleave', function () {
        choicesEl.classList.remove('drop-hot');
      });

      choicesEl.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });

      choicesEl.addEventListener('drop', function (e) {
        e.preventDefault();
        choicesEl.classList.remove('drop-hot');
        const cardId = e.dataTransfer.getData('text/plain') || dragCardId;
        if (!cardId) return;
        moveCardToChoices(cardId);
      });

      checkBtn.addEventListener('click', function () {
        const hasEmpty = slots.some(function (item) { return item === null; });

        if (hasEmpty) {
          messageEl.textContent = 'Fill all 6 slots before checking.';
          hasChecked = false;
          render();
          return;
        }

        hasChecked = true;

        let correctCount = 0;
        for (let i = 0; i < 6; i++) {
          if (slots[i] === correctOrder[i]) correctCount++;
        }

        if (correctCount === 6) {
          messageEl.textContent = 'All 6 correct!';
        } else {
          messageEl.textContent = correctCount + '/6 correct. Fix the red ones and check again.';
        }

        render();
      });

      resetBtn.addEventListener('click', function () {
        slots = new Array(6).fill(null);
        choices = shuffle(correctOrder);
        selectedCardId = null;
        hasChecked = false;
        isDragging = false;
        messageEl.textContent = '';
        render();
      });

      function init() {
        choices = shuffle(correctOrder);
        render();
      }

      init();
    })();
  </script>
</body>
</html>
